<!doctype html>
<html lang="en">

    <head>
        <meta charset="utf-8">

        <title>Hazelcast</title>

        <meta name="description" content="A framework for easily creating beautiful presentations using HTML">
        <meta name="author" content="Hakim El Hattab">

        <meta name="apple-mobile-web-app-capable" content="yes" />
        <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

        <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

        <link rel="stylesheet" href="css/reveal.min.css">
        <link rel="stylesheet" href="css/theme/sky.css" id="theme">

        <!-- For syntax highlighting -->
        <link rel="stylesheet" href="lib/css/zenburn.css">

        <!-- If the query includes 'print-pdf', include the PDF print sheet -->
        <script>
            if( window.location.search.match( /print-pdf/gi ) ) {
                var link = document.createElement( 'link' );
                link.rel = 'stylesheet';
                link.type = 'text/css';
                link.href = 'css/print/pdf.css';
                document.getElementsByTagName( 'head' )[0].appendChild( link );
            }
        </script>

        <!--[if lt IE 9]>
        <script src="lib/js/html5shiv.js"></script>
        <![endif]-->
    </head>

    <body>

        <div class="reveal">

            <!-- Any section element inside of this container is displayed as a slide -->
            <div class="slides">
                <section>
                    <h1>Hazelcast</h1>
                    <h3>Clustering Made "Easy"</h3>
                    <p>
                        <small><a href="http://coacoas.github.com">Bill Carlson</a> / <a href="http://twitter.com/coacoas">@coacoas</a></small>
                    </p>
                </section>

                <section>
                    <section>
                        <h3>Maps</h3>
                        <pre><code>
import java.util.HashMap;
import java.util.Map;

public class Lookup {
    public static void main(String[] args) { 
        Map&lt;Integer, String> m = new HashMap&lt;>();
        
        m.put(1, "London");
        m.put(2, "Tokyo");
        
        m.get(1);  // London
    }
}
                        </code>
                        </pre>
                    </section>
                    <section>
                        <h3>Thread-safe Maps</h3>
                                                <pre><code>
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

public class Lookup {
    public static void main(String[] args) { 
        Map&lt;Integer, String> m = new ConcurrentHashMap&lt;>();
        
        m.put(1, "London");
        m.put(2, "Tokyo");
        
        m.get(1);  // London
    }
}
                        </code>
                        </pre>

                    </section>
                    <section>
                        <h3>Distrubuted Maps</h3>
                                                <pre><code>
import com.hazelcast.core.Hazelcast;
import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.core.IMap;

public class Lookup {
    public static void main(String[] args) { 
        HazelcastInstance instance = Hazelcast.newHazelcastInstance();
        IMap&lt;Integer, String> m = instance.getMap("data");
        
        m.put(1, "London");
        m.put(2, "Tokyo");
        
        m.get(1);  // London
    }
}
                        </code>
                        </pre>

                    </section>
                </section>
                <section>
                    <section>
                        <h3>But wait, there's more!</h3>
                        <ul>
                            <li>Java Collections
                                <ul>
                                    <li>Map</li>
                                    <li>Set</li>
                                    <li>List</li>
                                    <li>Queue</li>
                                    <li>Multimap</li>
                                </ul>
                            </li>
                        </ul>
                    </section>
                    <section>
                        <h3>Topic Publish/Subscribe</h3>
                        <pre><code>
        ITopic&lt;String> topic = instance.getTopic("strings");
        topic.addMessageListener(new MessageListener&lt;String>() {
            @Override
            public void onMessage(Message&lt;String> msg) {
                System.out.println("Received: " + msg);
            }
        });
        
        topic.publish("New message");
                       </code></pre>
                    </section>

                    <section>
                        <h3>Queries</h3>
                        <pre><code class="language-scala">
case class Employee(name: String, 
                    age: Int, 
                    salary: Long, 
                    active: Boolean)

class Query {
    val instance = Hazelcast.newHazelcastInstance()
    val m = instance.getMap[Int, Employee]("personnel")
    
    m.put(1, Employee("Bill", 41, 50, false))
    m.put(2, Employee("Eyal", 25, 250000, true))

    val expensive: Collection[Employee] = 
        m.values(new SqlPredicate("active=true and salary > 100000"))
}
                        </code></pre>
                    </section>
                    <section>
                        <h3>Indexing</h3>
                        <pre><code class="language-scala">
class Query {
    val instance = Hazelcast.newHazelcastInstance()
    val m = instance.getMap[Int, Employee]("personnel")
    
    m.addIndex("name", false)
    m.addIndex("salary", true)

    val expensive: Collection[Employee] = 
        m.values(new SqlPredicate("active=true and salary > 100000"))
}
                        </code></pre>
                    </section>
                    <section>
                        <h3>Listeners</h3>
                        <pre><code class="language-scala">
import com.hazelcast.core.EntryEvent
import com.hazelcast.core.EntryListener

class Listener[K,V] extends EntryListener[K,V] { 
  override def entryAdded(e: EntryEvent[K,V]) = 
    println(s"Added (${e.getKey}, ${e.getValue}")
  override def entryEvicted(e: EntryEvent[K,V]) = 
    println(s"Evicted (${e.getKey}, ${e.getValue}")
  override def entryRemoved(e: EntryEvent[K,V]) = 
    println(s"Removed (${e.getKey}, ${e.getValue}")
  override def entryUpdated(e: EntryEvent[K,V]) = 
    println(s"Updated ${e.getKey} from ${e.getOldValue} to ${e.getValue}")
}
                        </code></pre>
                    </section>
                    <section>
                        <h3>Available on other collections, too</h3>
                        <pre><code class="language-java">
import com.hazelcast.core.ItemEvent;
import com.hazelcast.core.ItemListener;

public class LoggingItemListener&lt;E> implements ItemListener&lt;E> {
    @Override
    public void itemAdded(ItemEvent&lt;E> e) {
        System.out.println("Added " + e.getItem());
    }

    @Override
    public void itemRemoved(ItemEvent&lt;E> e) {
        System.out.println("Removed " + e.getItem());
    }
}
                        </code></pre>
                    </section>
                    <section>
                        <h3>Continuous Query</h3>
                        <ul>
                            <li>From the IMap interface:
                        <pre><code>
String addEntryListener(EntryListener&lt;K,V>, boolean) 
String addEntryListener(EntryListener&lt;K,V>, K, boolean) 
String addEntryListener(EntryListener&lt;K,V>, Predicate&lt;K,V>, boolean) 
String addEntryListener(EntryListener&lt;K,V>, Predicate&lt;K,V>, K, boolean) 

String addLocalEntryListener(EntryListener&lt;K,V>) 
String addLocalEntryListener(EntryListener&lt;K,V>, Predicate&lt;K,V>, boolean) 
String addLocalEntryListener(EntryListener&lt;K,V>, Predicate&lt;K,V>, K, boolean) 

void removeEntryListener(String id)
                        </code></pre>
                        </li>
                            <li>From ICollection:
                        <pre><code>
 String addItemListener(ItemListener&lt;E> listener, boolean includeValue) 
 boolean removeItemListener(String registrationId) 
                        </code></pre>
                            </li>
                        </ul>
                    </section>
                </section>
                <section>
                    <section>
                        <h3>Concurrency</h3>
                        <ul>
                            <li>Lock</li>
                            <li>Semaphore</li>
                        </ul>
                    </section>
                    <section>
                        <h3>Transactions</h3>
                        <pre><code>
HazelcastInstance instance = Hazelcast.newHazelcastInstance();
IMap&lt;Integer, String> m = instance.getMap("data");
TransactionContext ctx = instance.newTransactionContext();
try { 
    ctx.beginTransaction();
    m.put(1, "London");
    m.put(2, "Tokyo");
    m.put(3, "Jacksonville");
    m.put(4, "Paris");
    m.put(5, "New York");
    ctx.commitTransaction();
} catch (Exception e) { 
    ctx.rollbackTransaction();
}
                        </code></pre>
                    </section>
                    <section>
                        <h3>Executors</h3>
                        <pre><code>
HazelcastInstance instance = Hazelcast.newHazelcastInstance();
IExecutorService executor = instance.getExecutorService("default");

Future&lt;String> result = executor.submit(new Echo("Any Member"));

Future&lt;String> r2 = executor.submitToMember(new Echo("Specific Member"), 
        instance.getCluster().getLocalMember());

Map&lt;Member, Future&lt;String>> results = 
        executor.submitToAllMembers(new Echo("All members"));

                        </code></pre>
                        <p>Plus, you can have callbacks!</p>
                    </section>
                </section>

                <section>
                    <section>
                        <h3>And even more!</h3>
                        <ul>
                            <li>Interceptors</li>
                            <li>Near Cache</li>
                            <li>Hibernate Second Level Cache</li>
                            <li>Spring Integration</li>
                            <li>WAN Replication</li>
                            <li>HTTP Session Clustering</li>
                            <li>JMX Monitoring</li>
                            <li>SPI</li>
                        </ul>
                    </section>
                </section> 

                <section>
                    <section>
                        <h3>Now, in Hazelcast 3.2...</h3>
                        <h3 class="fragment">Map/Reduce</h3>
                    </section>
                    <section>
                        <h3>Workflow</h3>
                        <img src="images/mapreduce_workflow_small.png" alt="MapReduce Workflow">
                    </section>
                    <section>
                        <h3>Mapper</h3>
                        <pre><code class="language-java">
import java.util.StringTokenizer;

import com.hazelcast.mapreduce.Context;
import com.hazelcast.mapreduce.Mapper;

public class WordCountMapper implements
        Mapper&lt;String, String, String, Long> {

    @Override
    public void map(String key, String value, Context&lt;String, Long> context) {
        StringTokenizer tokenizer = new StringTokenizer( value.toLowerCase() );
        while ( tokenizer.hasMoreTokens() ) {
            context.emit( tokenizer.nextToken(), 1L );
        }
    }
}
                        </code></pre>
                    </section>
                    <section>
                        <h3>Combiner/CombinerFactory</h3>
                        <ul>
                            <li>Optional, but recommended</li>
                            <li>Used to reduce network traffic</li>
                            <li>"Intermediate Reducer"</li>
                            <li>Runs on single node</li>
                            <li>No locking/volatility required</li>
                        </ul>
                    </section>
                    <section>
                        <h3>CombinerFactory</h3>
                        <pre><code>
import com.hazelcast.mapreduce.Combiner;
import com.hazelcast.mapreduce.CombinerFactory;

public class WordCountCombinerFactory implements CombinerFactory&lt;String, Long, Long> {
    @Override
    public Combiner&lt;String, Long, Long> newCombiner( String key ) {
        return new WordCountCombiner();
    }

    private class WordCountCombiner extends Combiner&lt;String, Long, Long> {
        private long sum = 0;

        @Override
        public void combine( String key, Long value ) {
            sum++;
        }

        @Override
        public Long finalizeChunk() {
            long chunk = sum;
            sum = 0;
            return chunk;
        }
    }
}
                        </code></pre>
                    </section>
                    <section>
                        <h3>Reducer</h3>
                        <pre><code>
import com.hazelcast.mapreduce.Reducer;
import com.hazelcast.mapreduce.ReducerFactory;

public class WordCountReducerFactory implements ReducerFactory&lt;String, Long, Long> {
    @Override
    public Reducer&lt;String, Long, Long> newReducer( String key ) {
        return new WordCountReducer();
    }

    private class WordCountReducer extends Reducer&lt;String, Long, Long> {
        private volatile long sum = 0;

        @Override
        public void reduce( Long value ) {
            sum += value.longValue();
        }

        @Override
        public Long finalizeReduce() {
            return sum;
        }
    }
}
                        </code></pre>
                    </section>
                    <section>
                        <h3>Put it all together</h3>
                        <pre><code class="language-java">
HazelcastInstance instance = Hazelcast.newHazelcastInstance();
JobTracker tracker = instance.getJobTracker("word-count");
IMap&lt;String, String> data = instance.getMap("data");
KeyValueSource&lt;String, String> source = KeyValueSource.fromMap(data);
Job&lt;String, String> job = tracker.newJob(source);

JobCompletableFuture&lt;Map&lt;String, Long>> future = 
        job.mapper(new WordCountMapper()).
            combiner(new WordCountCombinerFactory()).
            reducer(new WordCountReducerFactory()).
            submit();
Map&lt;String, Long> result = future.get();
                        </code></pre>
                    </section>
                </section>

                <section>
                    <section>
                        <h3>Clients</h3>
                        <ul>
                            <li>Java</li>
                            <li>Memcache</li>
                            <li>REST</li>
                        </ul>
                    </section>
                </section>

                <section>
                    <section>
                        <h3>All Open Source</h3>
                        <p>Licensed using Apache 2.0</p>
                        <p class="fragment">Contained in a 2.6MB JAR</p>
                    </section>
                </section>

                <section>
                    <section>
                        <h3>What's the catch?</h3>
                    </section>
                    <section>
                        <h3>Serialization</h3>
                        <ul>
                            <li>java.io.Serializable</li>
                            <li>com.hazelcast.nio.serialization.DataSerializable</li>
                            <li>Custom Serialization (e.g., Kryo)</li>
                        </ul>
                    </section>
                    <section>
                        <h3>Unfamiliar behavior</h3>
                        <ul>
                            <li>IMap.get(K key) returns a <i>copy</i> of the value in the map</li>
                            <li>In-place updates are not reflected in the map unless .put() is called</li>
                        </ul>
                    </section>
                    <section>
                        <h3>Performance</h3>
                        <p>In Hazelcast 2.x</p>
                        <pre><code>
        final IMap&lt;Integer, String> m = instance.getMap("data");
        ILock l = instance.getLock("lock");
        try {
            l.lock();
            String value = m.get(1);
            m.put(1, value.toUpperCase());
        } finally {
            l.unlock();
        }
                        </code></pre>
                    </section>
                    <section>
                        <h3>Performance</h3>
                        <p>In Hazelcast 3.x</p>
                        <pre><code>
public abstract class AbstractProcessor&lt;K, V> 
  implements EntryProcessor&lt;K, V>, EntryBackupProcessor&lt;K, V> { 
    @Override
    public EntryBackupProcessor&lt;K, V> getBackupProcessor() {
        return this;
    }
    @Override
    public void processBackup(Entry&lt;K, V> arg0) {
        process(arg0);
    }
}
                        </code></pre>
                        <pre><code>
m.executeOnKey(1, new AbstractProcessor&lt;Integer, String>() {
    @Override
    public Object process(Entry&lt;Integer, String> arg0) {
        String newValue = arg0.getValue().toUpperCase();
        m.put(arg0.getKey(), newValue);
        return newValue;
    }
});
                        </code></pre>
                    </section>
                </section>

                <!--
                <section>
                    <section>
                        <h1>Demo</h1>
                    </section>
                </section>
                -->
                <section>
                    <section>
                        <h3>There is a <i>little</i> more...</h3>
                        <div class="fragment">
                            <p>Enterprise capabilities ($$$)
                            <ul>
                                <li>Management Console</li>
                                <li>Security</li>
                                <li>Elastic Memory</li>
                                <li>C# Client</li>
                                <li>C++ Client</li>
                            </ul>
                            </p>
                        </div>
                    </section>
                </section>
                <section>
                    <section>
                        <h3>Use Cases</h3>
                        <p>Use Hazelcast for:</p>
                        <ul>
                            <li>NoSQL KV Store</li>
                            <li>Messaging</li>
                            <li>Data Grid</li>
                            <li>Caching</li>
                            <li>Application Scaling</li>
                            <li>Clustering</li>
                        </ul>
                    </section>
                </section>
                <section>
                    <section>
                        <h3>Webinar</h3>
                        <p>Learn How To Speed Up Your Database With Hazelcast</p>
                        <a href="http://www.hazelcast.org/webinars/learn-how-to-speed-up-your-database-with-hazelcast/">http://www.hazelcast.org/webinars/learn-how-to-speed-up-your-database-with-hazelcast/</a>
                        <p>Wednesday, April 16th, 2014 — 1:00 PM EDT</p>
                    </section>
                </section>
                <section>
                    <section>
                        <h1>?</h1>
                    </section>
                </section>
            </div>

        </div>

        <script src="lib/js/head.min.js"></script>
        <script src="js/reveal.min.js"></script>

        <script>

            // Full list of configuration options available here:
            // https://github.com/hakimel/reveal.js#configuration
            Reveal.initialize({
                controls: true,
                progress: true,
                history: true,
                center: true,

                theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
                transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

                // Parallax scrolling
                // parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg',
                // parallaxBackgroundSize: '2100px 900px',

                // Optional libraries used to extend on reveal.js
                dependencies: [
                    { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
                    { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                    { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                    { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
                    { src: 'plugin/zoom-js/zoom.js', async: true, condition: function() { return !!document.body.classList; } },
                    { src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
                ]
            });

        </script>

    </body>
</html>
